from __future__ import annotations
import numpy as np
from numpy.typing import ArrayLike, NDArray

class AdEss:
    def __init__(self, threshold: int, n_max: int, weights: ArrayLike) -> None: ...
    def new_for_distribution_threshold(threshold: int, n_max: int, distribution: ArrayLike, res_factor: float) -> AdEss: ...
    def new_for_distribution_num_bits(num_bits: int, n_max: int, distribution: ArrayLike, res_factor: float) -> AdEss: ...
    def new_for_distribution_optimal_threshold(n_max: int, distribution: ArrayLike, res_factor: float, search_width: int, rev_trellis_calculation_fraction: float) -> AdEss: ...
    def weights_from_distribution(self, distribution: ArrayLike, res_factor: float) -> NDArray[np.uint64]: ...
    def encode(self, index_bits: ArrayLike) -> NDArray[np.uint64]: ...
    def multi_encode(self, multi_index_bits: ArrayLike) -> NDArray[np.uint64]: ...
    def decode(self, sequence: ArrayLike) -> NDArray[np.uint64]: ...
    def multi_decode(self, sequences: ArrayLike) -> NDArray[np.uint64]: ...
    def num_data_bits(self) -> int: ...
    def get_weights(self) -> NDArray[np.uint64]: ...
    def get_distribution(self, res_factor: float) -> NDArray[np.float32]: ...
    def amplitude_distribution(self) -> NDArray[np.float32]: ...
    def average_energy(self) -> float: ...
    def num_sequences_possible(self) -> str: ...
